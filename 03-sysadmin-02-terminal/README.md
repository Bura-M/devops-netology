## Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"
***

#### 1. Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.  
cd - встроенная в Linux команда изменения каталога, которая работае внутри сессии терминала.  

#### 2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос.
	grep <something> <somewhere> -c    
	cat <somewhere> | grep <something> -c    

![Вывод grep -c](https://github.com/Bura-M/devops-netology/blob/main/03-sysadmin-02-terminal/img/grep-c.PNG "grep -c")  


#### 3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?  
Процесс systemd.  
![Вывод pstree -p](https://github.com/Bura-M/devops-netology/blob/main/03-sysadmin-02-terminal/img/pstree-p.PNG "pstree -p")  

#### 4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?  
ls -l >/dev/pts/1  

#### 5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.  
cat <input.txt >output.txt  
![Вывод cat](https://github.com/Bura-M/devops-netology/blob/main/03-sysadmin-02-terminal/img/cat_inoutput.PNG "in&output")  


#### 6. Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?  
Попробовала:  
	vagrant@vagrant:$ who  
	vagrant  pts/0        2021-11-25 15:48 (10.0.2.2)  
	vagrant  pts/1        2021-11-25 17:11 (10.0.2.2)  
	vagrant@vagrant:$ echo Hello >/dev/tty1   

#### 7. Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?
5>&1 в командной строке текущего сеанса создаст новый файловый дескриптор "5" и перенаправит его в "1", т.е. в stdout.  
echo netology > /proc/$$/fd/5 - перенаправит вывод "netology" в созданный ранее дескриптор "5" (stdout).  

#### 8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.  
	vagrant@vagrant:~$ echo test 7>&2 2>&1 1>&7  
	test  

Создаю дескриптор 7, перенаправляю его в sterr, stderr перенаправляю в stdout и stdout перенаправляю в созданный дескриптор.  

#### 9. Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод? 
/proc/$$/environ - выведет переменные среды окружения (исходной).  
Аналоги: env и printenv. азница между этими двумя командами проявляется только в их более конкретной функциональности. Например, с помощью printenv вы можете запросить значения отдельных переменных: printenv SHELL.  
	vagrant@vagrant:~$ printenv SHELL  
	/bin/bash  

#### 10. Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.
man procfs  
/proc/<PID>/cmdline - содержит полную командную строку для процесса, если только процесс не является зомби (строка 178).  
/proc/<PID>/exe -  представляет собой символическую ссылку на исполняемый файл, который инициировал запуск процесса (строка 231).  

#### 11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.
Не очень поняла старшая версия - это самая старая или последняя, поэтому SSE2 и SSE4.2 согласно выводу: cat /proc/cpuinfo | grep sse   
![Вывод cpuinfo](https://github.com/Bura-M/devops-netology/blob/main/03-sysadmin-02-terminal/img/sse.PNG "SSE")  

#### 12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2 и ля-ля-ля (stdin: is not a tty).
По умолчанию, когда вы запускаете команду на удаленном компьютере с помощью ssh, TTY не выделяется для удаленного сеанса.  
При запуске ssh без удаленной команды, он ДЕЙСТВИТЕЛЬНО выделяет TTY, потому что вы, вероятно, будете запускать сеанс оболочки. Этого ожидает ssh 'tty' команда.  
[Объяснение](https://unix.stackexchange.com/questions/48527/ssh-inside-ssh-fails-with-stdin-is-not-a-tty "Статейка")  

Ключ -t приводит к принудительному выделению TTY.  
	vagrant@vagrant:~$ ssh -t localhost 'tty'  
	vagrant@localhost's password:  
	/dev/pts/1  
	Connection to localhost closed.  

#### 13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.  
Не очень поняла, что нужно сделать. Поэтому как-то так:  
![Выполнение screen](https://github.com/Bura-M/devops-netology/blob/main/03-sysadmin-02-terminal/img/screen.PNG "screen nano")  
![После выполнения screen](https://github.com/Bura-M/devops-netology/blob/main/03-sysadmin-02-terminal/img/after_screen.PNG "after screen nano")  

Далее нашла ответы коллег:  
	1. Изменить значение kernel.yama.ptrace_scope на 0 /etc/sysctl.d/10-ptrace.conf.  
	2. Перезагрузить ВМ: vagrant reload.  
	3. sudo reptyr -T [PID].  

#### 14. sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.  
Перенаправление вывода выполняется оболочкой, из которой была вызвана команда. По порядку происходит:  
1. вызывается оболочка sudo echo string, которая выполняет sudo команду с echo string командной строкой;  
2. sudo открывает суперпользовательскую оболочку и вызывает echo string, который запускает echo команду передачи его значения (string);   
3. echo, работающий с root-привилегиями, выводит строку в стандартный вывод;  
4. echo-команда завершается, суперпользовательская оболочка завершается, sudo завершается;  
5. оболочка, из которой была вызвана команда, собирает выходные данные и пытается перенаправить их в /root/new_file, что доступно для записи только пользователю root. Получает ошибку «Отказано в доступе».  

tee - команда, которая записывает в файл и выводит то, что записала (из man: tee - read from standard input and write to standard output and files).  
echo string | sudo tee /root/new_file - работает, так как сначала выполняется echo со стандартными параметрами, а потом tee в оболочке суперпользователя.  
