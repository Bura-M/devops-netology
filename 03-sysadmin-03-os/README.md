# Домашнее задание к занятию "3.3. Операционные системы, лекция 1"

***

### 1.Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой, это shell builtin, поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить strace на /bin/bash -c 'cd /tmp'. В этом случае вы увидите полный список системных вызовов, которые делает сам bash при старте. Вам нужно найти тот единственный, который относится именно к cd. Обратите внимание, что strace выдаёт результат своей работы в поток stderr, а не в stdout.
Системный вызов chdir("/tmp")  

### 2.Попробуйте использовать команду file на объекты разных типов на файловой системе. Например:
	vagrant@netology1:~$ file /dev/tty
	/dev/tty: character special (5/0)
	vagrant@netology1:~$ file /dev/sda
	/dev/sda: block special (8/0)
	vagrant@netology1:~$ file /bin/bash
	/bin/bash: ELF 64-bit LSB shared object, x86-64  
	
Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.  

######Согласно выводу strace file база данных находится "/usr/share/misc/magic.mgc"  
	read(3, "# Magic local data for file(1) c"..., 4096) = 111  
	read(3, "", 4096)                       = 0  
	close(3)                                = 0  
	openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3  

Вопрос: где мне это пригодится?  

### 3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).  
Предварительно удалила файл /var/log/audit/audit.log, PID процесса 1587.  
	
	sudo lsof -nP | grep '(deleted)'  
,которое выведет  
auditd     1587                           root    5w      REG              253,0     1252    1442463 /var/log/audit/audit.log (deleted)  

или  
	sudo find /proc/1587/fd -ls | grep  '(deleted)'  

Далее:	
	echo -n >/proc/1587/fd/5
или (если вариант выше выдал Permission Denied)
	echo -n | sudo tee /proc/1587/fd/5

### 4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
Когда дочерний процесс получает команду на завершение, он освобождает все используемые ресурсы и продолжает как зомби существовать в системе с ранее присвоенным ему PID. Далее с помощью сигнала SIGCHLD система уведомляет родительский процесс о завершении зомби процесса. Если по какой-либо причине родительский процесс игнорирует этот сигнал, то зомби процесс так и продолжает отображаться в системе.  

Зомби процессы не используют системные ресурсы, поэтому их можно просто игнорировать. Убить зомби процесс на прямую командой kill не получится. В данном случае единственный вариант полностью убрать зомби процесс — убить или перезапустить его родительский процесс.  


### 5. В iovisor BCC есть утилита opensnoop:
	root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
	/usr/sbin/opensnoop-bpfcc
	
На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04. Дополнительные сведения по установке.  

Не очень поняла, что и зачем, но та-да:  
![Вывод bpfcc-tools](https://github.com/Bura-M/devops-netology/blob/main/03-sysadmin-03-os/img/bpfcc-tools.PNG "bpfcc-tools")  

### 6. Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.  
	sudo apt install manpages-dev
	man 2 uname
>Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.  

uname -a использует системный вызов uname().  

### 7. Чем отличается последовательность команд через ; и через && в bash? Например:
	root@netology1:~# test -d /tmp/some_dir; echo Hi
	Hi
	root@netology1:~# test -d /tmp/some_dir && echo Hi
	root@netology1:~# 
	
Есть ли смысл использовать в bash &&, если применить set -e?  

"&&" - логический оператор  
";" - это простая последовательность.  

В <test -d /tmp/some_dir && echo Hi> я увижу приветсвие, только если test -d завершится с успешным кодом возврата.  
В <test -d /tmp/some_dir ; echo Hi> - echo неважно, как завершится выполнение test и терминал со мной поздоровается в любом случае(при условии, что вы не настроили свою оболочку на выход при всех сбоях в вашем скрипте или чем-то еще).  

man bash говорит, что set -e позволяет завершать весь скрипт, если команда завершилась с ошибкой (не 0). Команды, объединенные && или || считаются единым командным выражением, потому принимается в расчет результат всего выражения. Механизм set -e позволяет получить предсказуемые скрипты, которые не "проглатывают" ошибку и выполняются дальше, а завершаются с кодом возврата команды => нет смысла использовать set -e и логически И одновременно.  

### 8. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?
-e - немедленное завершение команды, если она завершается с ненулевым статусом/ошибкой  
-u - при попытке обращения к неопределенным переменным, выдает сообщение об ошибке и прерывает работу сценария  
-x - выводит команды и их аргументы по мере их выполнения  
-o pipefail - возвращает возвращаемое значение конвейера - это значение последней (самой правой) команды для выхода с ненулевым статусом или ноль, если все команды в конвейере завершаются успешно.  

Хорошо для детализации лога и остановки сценария на любом ошибочном моменте.  

### 9. Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).
Вывод команды ps -o stat:  
STAT  
Ss  
R+  

Ss - спящие процессы или процессы ожидающие события, чтобы завершиться (interruptible sleep (waiting for an event to complete))  
R+ - исполняемые/работающие процессы  

Дополнительные флаги:  
< — процесс имеет повышенный приоритет  
N — процесс имеет пониженный приоритет  
L — некоторые страницы блокированы в оперативной памяти  
s — процесс является лидером сеанса  
l - многопоточный процесс  
"+" - процесс входит в группу процессов "переднего" плана (обычно определенных терминалом)  
